<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CUDPP: A Simple CUDPP Example</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="example_simpleCUDPP">A Simple CUDPP Example </a></h1><p>This code sample demonstrates a basic usage of CUDPP for computing the parallel prefix sum of a floating point array on the GPU.</p>
<h2><a class="anchor" id="codeWalkthrough">
Sample Code Walkthrough</a></h2>
<p>The simpleCUDPP sample is the "hello" world example for CUDPP. Its aim is to show you how to initialize, run, and shut down CUDPP functions.</p>
<p>The main function in simpleCUDPP.cu is <code>runTest()</code>.</p>
<h3><a class="anchor" id="runTest">
runTest()</a></h3>
<p>simpleCUDPP uses libCUTIL, a CUDA utility library used in NVIDIA CUDA SDK samples to initialize CUDA and to check for errors. <code>runTest</code> starts by initializing the CUDA device and then declaring the number of elements and the array size for the arrays we plan to scan. It then allocates the host-side (CPU-side) input array, <code>h_idata</code>, and initializes the data it contains with some random values between 0 and 15.</p>
<p><div class="fragment"><pre class="fragment"><span class="keywordtype">void</span>
runTest( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) 
{
    CUT_DEVICE_INIT(argc, argv);

    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numElements = 32768;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> memSize = <span class="keyword">sizeof</span>( float) * numElements;

    <span class="comment">// allocate host memory</span>
    <span class="keywordtype">float</span>* h_idata = (<span class="keywordtype">float</span>*) malloc( memSize);
    <span class="comment">// initalize the memory</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; numElements; ++i) 
    {
        h_idata[i] = (float) (rand() &amp; 0xf);
    }
</pre></div></p>
<p>After the input data is created on the host, we allocate a device (GPU) array <code>d_idata</code> and copy the input data from the host using <code>cudaMemcpy()</code>. We also allocate a device array for the output results, <code>d_odata</code>.</p>
<p><div class="fragment"><pre class="fragment">
    <span class="comment">// allocate device memory</span>
    <span class="keywordtype">float</span>* d_idata;
    CUDA_SAFE_CALL( cudaMalloc( (<span class="keywordtype">void</span>**) &amp;d_idata, memSize));
    <span class="comment">// copy host memory to device</span>
    CUDA_SAFE_CALL( cudaMemcpy( d_idata, h_idata, memSize,
                                cudaMemcpyHostToDevice) );

    <span class="comment">// allocate device memory for result</span>
    <span class="keywordtype">float</span>* d_odata;
    CUDA_SAFE_CALL( cudaMalloc( (<span class="keywordtype">void</span>**) &amp;d_odata, memSize));
</pre></div></p>
<h3><a class="anchor" id="plans">
CUDPP Plans</a></h3>
<p>Next comes the real CUDPP stuff. First we have to configure CUDPP to scan our array. Configuration of algorithms in CUDPP relies on the concept of the <em>plan</em>. A plan is a data structure that maintains intermediate storage for the algorithm, as well as information that CUDPP may use to optimize execution of the present hardware. When invoked using <a class="el" href="group__public_interface.html#ga0d39e7c3e14963c7cc3df3b879362c25" title="Create a CUDPP plan.">cudppPlan()</a>, the CUDPP planner takes the configuration details passed to it and generates an internal plan object. It returns a CUDPPHandle -- an opaque pointer type that is used to refer to the plan object -- that must be passed to other CUDPP functions in order to execute algorithms.</p>
<p>In this case we are going to do a forward exclusive <code>float</code> sum-scan of <code>numElements</code> elements. We tell the planner this by filling out a <a class="el" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when...">CUDPPConfiguration</a> struct with the algorithm (CUDPP_SCAN), datatype (CUDPP_FLOAT), operation (CUDPP_ADD), and options (CUDPP_OPTION_FORWARD, CUDPP_OPTION_EXCLUSIVE). We then pass this <em>config</em> to cudppPlan along with the maximum number of elements we want to scan, <em>numElements</em>. Finally, we pass 1 and 0 for the <em>numRows</em> and <em>rowPitch</em> parameters, since we only want to scan a one-dimensional array. See the documentation for <a class="el" href="group__public_interface.html#ga0d39e7c3e14963c7cc3df3b879362c25" title="Create a CUDPP plan.">cudppPlan()</a> for more details on these parameters.</p>
<p><div class="fragment"><pre class="fragment">
    <a class="code" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when...">CUDPPConfiguration</a> config;
    config.<a class="code" href="struct_c_u_d_p_p_configuration.html#a78a6e0a90e97b79be8850ae3dff7819e" title="The numerical operator to be applied.">op</a> = <a class="code" href="cudpp_8h.html#afbc449e0243beebf799175ba0633a386a2464c1df67b312f9b1461e0214ed5ade" title="Addition of two operands.">CUDPP_ADD</a>;
    config.<a class="code" href="struct_c_u_d_p_p_configuration.html#a8127968c4b5c05d22956e2baa41a664d" title="The datatype of the input arrays.">datatype</a> = <a class="code" href="cudpp_8h.html#a8d0edad02eb8303164acb8f4abca612dafe9aa2a2ea7725eb0ea758a8dbc54399" title="Float type (C float).">CUDPP_FLOAT</a>;
    config.<a class="code" href="struct_c_u_d_p_p_configuration.html#a2d11e99b0c4a2b919c0bdb1c5001acfe" title="The algorithm to be used.">algorithm</a> = <a class="code" href="cudpp_8h.html#a6499e5c26f56db82f520367ae853462fa82cf703e248569c24544c3792048e06f" title="Scan or prefix-sum.">CUDPP_SCAN</a>;
    config.<a class="code" href="struct_c_u_d_p_p_configuration.html#a32140ada5ca87b081d1cd42d29a18c11" title="Options to configure the algorithm.">options</a> = <a class="code" href="cudpp_8h.html#afdaa492f807dd46b6b529a7f962d3576af3195c0a67325a796954c781372c7e13">CUDPP_OPTION_FORWARD</a> | <a class="code" href="cudpp_8h.html#afdaa492f807dd46b6b529a7f962d3576a65c9029495c4bda89f73435c221cc46b">CUDPP_OPTION_EXCLUSIVE</a>;
    
    CUDPPHandle scanplan = 0;
    <a class="code" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a" title="CUDPP Result codes returned by CUDPP API functions.">CUDPPResult</a> result = <a class="code" href="group__public_interface.html#ga0d39e7c3e14963c7cc3df3b879362c25" title="Create a CUDPP plan.">cudppPlan</a>(&amp;scanplan, config, numElements, 1, 0);  

    <span class="keywordflow">if</span> (<a class="code" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0aa593cd6a69fc69e6a186a2d53d4e13dbd">CUDPP_SUCCESS</a> != result)
    {
        printf(<span class="stringliteral">&quot;Error creating CUDPPPlan\n&quot;</span>);
        exit(-1);
    }
</pre></div></p>
<p>We now have a handle to our plan object in <em>scanplan</em>. Next, after making sure that <a class="el" href="group__public_interface.html#ga0d39e7c3e14963c7cc3df3b879362c25" title="Create a CUDPP plan.">cudppPlan()</a> did not return an error, we put CUDPP to work by invoking <a class="el" href="group__public_interface.html#ga6d637cd697e495985afbb1c3e64a21f7" title="Performs a scan operation of numElements on its input in GPU memory (d_in) and places...">cudppScan()</a>, to which we pass our plan handle, the output and input device arrays, and the number of elements to scan.</p>
<p><div class="fragment"><pre class="fragment">    <span class="comment">// Run the scan</span>
    <a class="code" href="group__public_interface.html#ga6d637cd697e495985afbb1c3e64a21f7" title="Performs a scan operation of numElements on its input in GPU memory (d_in) and places...">cudppScan</a>(scanplan, d_odata, d_idata, numElements);
</pre></div></p>
<p>Next, we read the results of the scan from d_odata back to the host, compute a reference solution on the CPU (<code>computeSumScanGold()</code>), and compare the results for correctness.</p>
<p><div class="fragment"><pre class="fragment">
    <span class="comment">// allocate mem for the result on host side</span>
    <span class="keywordtype">float</span>* h_odata = (<span class="keywordtype">float</span>*) malloc( memSize);
    <span class="comment">// copy result from device to host</span>
    CUDA_SAFE_CALL( cudaMemcpy( h_odata, d_odata, memSize,
                                cudaMemcpyDeviceToHost) );
    <span class="comment">// compute reference solution</span>
    <span class="keywordtype">float</span>* reference = (<span class="keywordtype">float</span>*) malloc( memSize);
    computeSumScanGold( reference, h_idata, numElements, config);

    <span class="comment">// check result</span>
    CUTBoolean res = cutComparef( reference, h_odata, numElements);
    printf( <span class="stringliteral">&quot;Test %s\n&quot;</span>, (1 == res) ? <span class="stringliteral">&quot;PASSED&quot;</span> : <span class="stringliteral">&quot;FAILED&quot;</span>);
</pre></div></p>
<p>Finally, we tell CUDPP to clean up the memory used for our plan object, using <a class="el" href="group__public_interface.html#ga4015898886e140ad95f320ab4c07db2c" title="Destroy a CUDPP Plan.">cudppDestroyPlan()</a>. Then we free the host and device arrays using <code>free()</code> and <code>cudaFree</code>, respectively. After that we're finished.</p>
<p><div class="fragment"><pre class="fragment">
    result = <a class="code" href="group__public_interface.html#ga4015898886e140ad95f320ab4c07db2c" title="Destroy a CUDPP Plan.">cudppDestroyPlan</a>(scanplan);
    <span class="keywordflow">if</span> (<a class="code" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0aa593cd6a69fc69e6a186a2d53d4e13dbd">CUDPP_SUCCESS</a> != result)
    {
        printf(<span class="stringliteral">&quot;Error destroying CUDPPPlan\n&quot;</span>);
        exit(-1);
    }
</pre></div></p>
<p>Using CUDPP for parallel prefix sums is easy! </p>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Thu Jan 21 11:52:57 2010 for CUDPP by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
