<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CUDPP: CUDPP Public Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>CUDPP Public Interface</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Algorithm Interface</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp43e28c027b7605d97c0bb547aef8b2eb"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga6d637cd697e495985afbb1c3e64a21f7">cudppScan</a> (CUDPPHandle planHandle, void *d_out, const void *d_in, size_t numElements)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a scan operation of numElements on its input in GPU memory (d_in) and places the output in GPU memory (d_out), with the scan parameters specified in the plan pointed to by planHandle.  <a href="#ga6d637cd697e495985afbb1c3e64a21f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga34b57db9dc1207031be684922559cf8d">cudppSegmentedScan</a> (CUDPPHandle planHandle, void *d_out, const void *d_idata, const unsigned int *d_iflags, size_t numElements)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a segmented scan operation of numElements on its input in GPU memory (d_idata) and places the output in GPU memory (d_out), with the scan parameters specified in the plan pointed to by planHandle.  <a href="#ga34b57db9dc1207031be684922559cf8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gaa7ee75839fc5b9679ef17bc68669b37c">cudppMultiScan</a> (CUDPPHandle planHandle, void *d_out, const void *d_in, size_t numElements, size_t numRows)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs numRows parallel scan operations of numElements each on its input (d_in) and places the output in d_out, with the scan parameters set by config. Exactly like cudppScan except that it runs on multiple rows in parallel.  <a href="#gaa7ee75839fc5b9679ef17bc68669b37c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga275bcc2d5cb5b0277027140aae9c51bd">cudppCompact</a> (CUDPPHandle planHandle, void *d_out, size_t *d_numValidElements, const void *d_in, const unsigned int *d_isValid, size_t numElements)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given an array <em>d_in</em> and an array of 1/0 flags in <em>deviceValid</em>, returns a compacted array in <em>d_out</em> of corresponding only the "valid" values from <em>d_in</em>.  <a href="#ga275bcc2d5cb5b0277027140aae9c51bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga97e4fdb95310da07ea59d1ac78cfd464">cudppSort</a> (CUDPPHandle planHandle, void *d_keys, void *d_values, int keyBits, size_t numElements)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts key-value pairs or keys only.  <a href="#ga97e4fdb95310da07ea59d1ac78cfd464"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga1a1c352037b5fd16a5468b0dae3b4cae">cudppSparseMatrixVectorMultiply</a> (CUDPPHandle sparseMatrixHandle, void *d_y, const void *d_x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform matrix-vector multiply y = A*x for arbitrary sparse matrix A and vector x.  <a href="#ga1a1c352037b5fd16a5468b0dae3b4cae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gaf53eeccf8944b52aca4acdcc096dd240">cudppRand</a> (CUDPPHandle planHandle, void *d_out, size_t numElements)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rand puts <em>numElements</em> random 32-bit elements into <em>d_out</em>.  <a href="#gaf53eeccf8944b52aca4acdcc096dd240"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga9120af9942d2553d2f376ede0f7079dd">cudppRandSeed</a> (const CUDPPHandle planHandle, unsigned int seed)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the seed used for rand.  <a href="#ga9120af9942d2553d2f376ede0f7079dd"></a><br/></td></tr>
<tr><td colspan="2"><h2>Plan Interface</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp1a6fe3a5203cb363a7d1a6cbbd1b08a3"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga0d39e7c3e14963c7cc3df3b879362c25">cudppPlan</a> (CUDPPHandle *planHandle, <a class="el" href="struct_c_u_d_p_p_configuration.html">CUDPPConfiguration</a> config, size_t numElements, size_t numRows, size_t rowPitch)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a CUDPP plan.  <a href="#ga0d39e7c3e14963c7cc3df3b879362c25"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga4015898886e140ad95f320ab4c07db2c">cudppDestroyPlan</a> (CUDPPHandle planHandle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a CUDPP Plan.  <a href="#ga4015898886e140ad95f320ab4c07db2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga4ef1a005ba96fccd6eb4204dc33f4f88">cudppSparseMatrix</a> (CUDPPHandle *sparseMatrixHandle, <a class="el" href="struct_c_u_d_p_p_configuration.html">CUDPPConfiguration</a> config, size_t numNonZeroElements, size_t numRows, const void *A, const unsigned int *h_rowIndices, const unsigned int *h_indices)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a CUDPP Sparse Matrix Object.  <a href="#ga4ef1a005ba96fccd6eb4204dc33f4f88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gae0644c758120abaef0e2bb396f57cefb">cudppDestroySparseMatrix</a> (CUDPPHandle sparseMatrixHandle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a CUDPP Sparse Matrix Object.  <a href="#gae0644c758120abaef0e2bb396f57cefb"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The CUDA public interface comprises the functions, structs, and enums defined in <a class="el" href="cudpp_8h.html" title="Main library header file. Defines public interface.">cudpp.h</a>. Public interface functions call functions in the <a class="el" href="group__cudpp__app.html">Application-Level</a> interface. The public interface functions include Plan Interface functions and Algorithm Interface functions. Plan Inteface functions are used for creating CUDPP Plan objects which contain configuration details, intermediate storage space, and in the case of <a class="el" href="group__public_interface.html#ga4ef1a005ba96fccd6eb4204dc33f4f88" title="Create a CUDPP Sparse Matrix Object.">cudppSparseMatrix()</a>, data. The Algorithm Interface is the set of functions that do the real work of CUDPP, such as <a class="el" href="group__public_interface.html#ga6d637cd697e495985afbb1c3e64a21f7" title="Performs a scan operation of numElements on its input in GPU memory (d_in) and places...">cudppScan()</a> and cudppSparseMatrixVectorMultiply. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga6d637cd697e495985afbb1c3e64a21f7"></a><!-- doxytag: member="cudpp.cpp::cudppScan" ref="ga6d637cd697e495985afbb1c3e64a21f7" args="(CUDPPHandle planHandle, void *d_out, const void *d_in, size_t numElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppScan </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&nbsp;</td>
          <td class="paramname"> <em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>numElements</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a scan operation of numElements on its input in GPU memory (d_in) and places the output in GPU memory (d_out), with the scan parameters specified in the plan pointed to by planHandle. </p>
<p>The input to a scan operation is an input array, a binary associative operator (like + or max), and an identity element for that operator (+'s identity is 0). The output of scan is the same size as its input. Informally, the output at each element is the result of operator applied to each input that comes before it. For instance, the output of sum-scan at each element is the sum of all the input elements before that input.</p>
<p>More formally, for associative operator  &oplus;, <em>out<sub>i</sub></em> = <em>in<sub>0</sub></em>  &oplus; <em>in<sub>1</sub></em>  &oplus; ...  &oplus; <em>in<sub>i-1</sub></em>.</p>
<p>CUDPP supports "exclusive" and "inclusive" scans. For the ADD operator, an exclusive scan computes the sum of all input elements before the current element, while an inclusive scan computes the sum of all input elements up to and including the current element.</p>
<p>Before calling scan, create an internal plan using <a class="el" href="group__public_interface.html#ga0d39e7c3e14963c7cc3df3b879362c25" title="Create a CUDPP plan.">cudppPlan()</a>.</p>
<p>After you are finished with the scan plan, clean up with <a class="el" href="group__public_interface.html#ga4015898886e140ad95f320ab4c07db2c" title="Destroy a CUDPP Plan.">cudppDestroyPlan()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>planHandle</em>&nbsp;</td><td>Handle to plan for this scan </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>d_out</em>&nbsp;</td><td>output of scan, in GPU memory </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>d_in</em>&nbsp;</td><td>input to scan, in GPU memory </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numElements</em>&nbsp;</td><td>number of elements to scan</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__public_interface.html#ga0d39e7c3e14963c7cc3df3b879362c25" title="Create a CUDPP plan.">cudppPlan</a>, <a class="el" href="group__public_interface.html#ga4015898886e140ad95f320ab4c07db2c" title="Destroy a CUDPP Plan.">cudppDestroyPlan</a> </dd></dl>

<p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>Return more specific errors </dd></dl>
</p>

</div>
</div>
<a class="anchor" id="ga34b57db9dc1207031be684922559cf8d"></a><!-- doxytag: member="cudpp.cpp::cudppSegmentedScan" ref="ga34b57db9dc1207031be684922559cf8d" args="(CUDPPHandle planHandle, void *d_out, const void *d_idata, const unsigned int *d_iflags, size_t numElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppSegmentedScan </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&nbsp;</td>
          <td class="paramname"> <em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>d_idata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&nbsp;</td>
          <td class="paramname"> <em>d_iflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>numElements</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a segmented scan operation of numElements on its input in GPU memory (d_idata) and places the output in GPU memory (d_out), with the scan parameters specified in the plan pointed to by planHandle. </p>
<p>The input to a segmented scan operation is an input array of data, an input array of flags which demarcate segments, a binary associative operator (like + or max), and an identity element for that operator (+'s identity is 0). The array of flags is the same length as the input with 1 marking the the first element of a segment and 0 otherwise. The output of segmented scan is the same size as its input. Informally, the output at each element is the result of operator applied to each input that comes before it in that segment. For instance, the output of segmented sum-scan at each element is the sum of all the input elements before that input in that segment.</p>
<p>More formally, for associative operator  &oplus;, <em>out<sub>i</sub></em> = <em>in<sub>k</sub></em>  &oplus; <em>in<sub>k+1</sub></em>  &oplus; ...  &oplus; <em>in<sub>i-1</sub></em>. <em>k</em> is the index of the first element of the segment in which <em>i</em> lies</p>
<p>We support both "exclusive" and "inclusive" variants. For a segmented sum-scan, the exclusive variant computes the sum of all input elements before the current element in that segment, while the inclusive variant computes the sum of all input elements up to and including the current element, in that segment.</p>
<p>Before calling segmented scan, create an internal plan using <a class="el" href="group__public_interface.html#ga0d39e7c3e14963c7cc3df3b879362c25" title="Create a CUDPP plan.">cudppPlan()</a>.</p>
<p>After you are finished with the scan plan, clean up with <a class="el" href="group__public_interface.html#ga4015898886e140ad95f320ab4c07db2c" title="Destroy a CUDPP Plan.">cudppDestroyPlan()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>planHandle</em>&nbsp;</td><td>Handle to plan for this scan </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>d_out</em>&nbsp;</td><td>output of segmented scan, in GPU memory </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>d_idata</em>&nbsp;</td><td>input data to segmented scan, in GPU memory </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>d_iflags</em>&nbsp;</td><td>input flags to segmented scan, in GPU memory </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numElements</em>&nbsp;</td><td>number of elements to perform segmented scan on</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__public_interface.html#ga0d39e7c3e14963c7cc3df3b879362c25" title="Create a CUDPP plan.">cudppPlan</a>, <a class="el" href="group__public_interface.html#ga4015898886e140ad95f320ab4c07db2c" title="Destroy a CUDPP Plan.">cudppDestroyPlan</a> </dd></dl>

<p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>Return more specific errors </dd></dl>
</p>

</div>
</div>
<a class="anchor" id="gaa7ee75839fc5b9679ef17bc68669b37c"></a><!-- doxytag: member="cudpp.cpp::cudppMultiScan" ref="gaa7ee75839fc5b9679ef17bc68669b37c" args="(CUDPPHandle planHandle, void *d_out, const void *d_in, size_t numElements, size_t numRows)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppMultiScan </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&nbsp;</td>
          <td class="paramname"> <em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>numRows</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs numRows parallel scan operations of numElements each on its input (d_in) and places the output in d_out, with the scan parameters set by config. Exactly like cudppScan except that it runs on multiple rows in parallel. </p>
<p>Note that to achieve good performance with cudppMultiScan one should allocate the device arrays passed to it so that all rows are aligned to the correct boundaries for the architecture the app is running on. The easy way to do this is to use cudaMallocPitch() to allocate a 2D array on the device. Use the <em>rowPitch</em> parameter to <a class="el" href="group__public_interface.html#ga0d39e7c3e14963c7cc3df3b879362c25" title="Create a CUDPP plan.">cudppPlan()</a> to specify this pitch. The easiest way is to pass the device pitch returned by cudaMallocPitch to <a class="el" href="group__public_interface.html#ga0d39e7c3e14963c7cc3df3b879362c25" title="Create a CUDPP plan.">cudppPlan()</a> via <em>rowPitch</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>planHandle</em>&nbsp;</td><td>handle to <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm.">CUDPPScanPlan</a> </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>d_out</em>&nbsp;</td><td>output of scan, in GPU memory </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>d_in</em>&nbsp;</td><td>input to scan, in GPU memory </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numElements</em>&nbsp;</td><td>number of elements (per row) to scan </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numRows</em>&nbsp;</td><td>number of rows to scan in parallel</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__public_interface.html#ga6d637cd697e495985afbb1c3e64a21f7" title="Performs a scan operation of numElements on its input in GPU memory (d_in) and places...">cudppScan</a>, <a class="el" href="group__public_interface.html#ga0d39e7c3e14963c7cc3df3b879362c25" title="Create a CUDPP plan.">cudppPlan</a> </dd></dl>

<p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>Return more specific errors </dd></dl>
</p>

</div>
</div>
<a class="anchor" id="ga275bcc2d5cb5b0277027140aae9c51bd"></a><!-- doxytag: member="cudpp.cpp::cudppCompact" ref="ga275bcc2d5cb5b0277027140aae9c51bd" args="(CUDPPHandle planHandle, void *d_out, size_t *d_numValidElements, const void *d_in, const unsigned int *d_isValid, size_t numElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppCompact </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&nbsp;</td>
          <td class="paramname"> <em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>d_numValidElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&nbsp;</td>
          <td class="paramname"> <em>d_isValid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>numElements</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given an array <em>d_in</em> and an array of 1/0 flags in <em>deviceValid</em>, returns a compacted array in <em>d_out</em> of corresponding only the "valid" values from <em>d_in</em>. </p>
<p>Takes as input an array of elements in GPU memory (<em>d_in</em>) and an equal-sized unsigned int array in GPU memory (<em>deviceValid</em>) that indicate which of those input elements are valid. The output is a packed array, in GPU memory, of only those elements marked as valid.</p>
<p>Internally, uses cudppScan.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> d_in    = [ a b c d e f ]
 deviceValid = [ 1 0 1 1 0 1 ]
 d_out   = [ a c d f ]
</pre></div><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>[MJH] We need to evaluate whether cudppCompact should be a core member of the public interface. It's not clear to me that what the user always wants is a final compacted array. Often one just wants the array of indices to which each input element should go in the output. The split() routine used in radix sort might make more sense to expose.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>planHandle</em>&nbsp;</td><td>handle to <a class="el" href="class_c_u_d_p_p_compact_plan.html" title="Plan class for compact algorithm.">CUDPPCompactPlan</a> </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>d_out</em>&nbsp;</td><td>compacted output </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>d_numValidElements</em>&nbsp;</td><td>set during cudppCompact; is set with the number of elements valid flags in the d_isValid input array </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>d_in</em>&nbsp;</td><td>input to compact </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>d_isValid</em>&nbsp;</td><td>which elements in d_in are valid </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numElements</em>&nbsp;</td><td>number of elements in d_in </td></tr>
  </table>
  </dd>
</dl>

<p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>Return more specific errors. </dd></dl>
</p>

</div>
</div>
<a class="anchor" id="ga97e4fdb95310da07ea59d1ac78cfd464"></a><!-- doxytag: member="cudpp.cpp::cudppSort" ref="ga97e4fdb95310da07ea59d1ac78cfd464" args="(CUDPPHandle planHandle, void *d_keys, void *d_values, int keyBits, size_t numElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppSort </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&nbsp;</td>
          <td class="paramname"> <em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>d_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>keyBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>numElements</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sorts key-value pairs or keys only. </p>
<p>Takes as input an array of keys in GPU memory (d_keys) and an optional array of corresponding values, and outputs sorted arrays of keys and (optionally) values in place. Key-value and key-only sort is selected through the configuration of the plan, using the options CUDPP_OPTION_KEYS_ONLY and CUDPP_OPTION_KEY_VALUE_PAIRS.</p>
<p>Supported key types are CUDPP_FLOAT and CUDPP_UINT. Values can be any 32-bit type (internally, values are treated only as a payload and cast to unsigned int).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>Determine if we need to provide an "out of place" sort interface.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>planHandle</em>&nbsp;</td><td>handle to CUDPPSortPlan </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>d_keys</em>&nbsp;</td><td>keys by which key-value pairs will be sorted </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>d_values</em>&nbsp;</td><td>values to be sorted </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>keyBits</em>&nbsp;</td><td>the number of least significant bits in each element of d_keys to sort by </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numElements</em>&nbsp;</td><td>number of elements in d_keys and d_values</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__public_interface.html#ga0d39e7c3e14963c7cc3df3b879362c25" title="Create a CUDPP plan.">cudppPlan</a>, <a class="el" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when...">CUDPPConfiguration</a>, <a class="el" href="cudpp_8h.html#a6499e5c26f56db82f520367ae853462f" title="Algorithms supported by CUDPP. Used to create appropriate plans using cudppPlan.">CUDPPAlgorithm</a> </dd></dl>

<p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd>Return more specific errors. </dd></dl>
</p>

</div>
</div>
<a class="anchor" id="ga1a1c352037b5fd16a5468b0dae3b4cae"></a><!-- doxytag: member="cudpp.cpp::cudppSparseMatrixVectorMultiply" ref="ga1a1c352037b5fd16a5468b0dae3b4cae" args="(CUDPPHandle sparseMatrixHandle, void *d_y, const void *d_x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppSparseMatrixVectorMultiply </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&nbsp;</td>
          <td class="paramname"> <em>sparseMatrixHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>d_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>d_x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform matrix-vector multiply y = A*x for arbitrary sparse matrix A and vector x. </p>
<p>Given a matrix object handle (which has been initialized using <a class="el" href="group__public_interface.html#ga4ef1a005ba96fccd6eb4204dc33f4f88" title="Create a CUDPP Sparse Matrix Object.">cudppSparseMatrix()</a>), This function multiplies the input vector <em>d_x</em> by the matrix referred to by <em>sparseMatrixHandle</em>, returning the result in <em>d_y</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sparseMatrixHandle</em>&nbsp;</td><td>Handle to a sparse matrix object created with <a class="el" href="group__public_interface.html#ga4ef1a005ba96fccd6eb4204dc33f4f88" title="Create a CUDPP Sparse Matrix Object.">cudppSparseMatrix()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>d_y</em>&nbsp;</td><td>The output vector, y </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>d_x</em>&nbsp;</td><td>The input vector, x</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__public_interface.html#ga4ef1a005ba96fccd6eb4204dc33f4f88" title="Create a CUDPP Sparse Matrix Object.">cudppSparseMatrix</a>, <a class="el" href="group__public_interface.html#gae0644c758120abaef0e2bb396f57cefb" title="Destroy a CUDPP Sparse Matrix Object.">cudppDestroySparseMatrix</a> </dd></dl>

<p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000012">Todo:</a></b></dt><dd>Return more specific errors. </dd></dl>
</p>

</div>
</div>
<a class="anchor" id="gaf53eeccf8944b52aca4acdcc096dd240"></a><!-- doxytag: member="cudpp.cpp::cudppRand" ref="gaf53eeccf8944b52aca4acdcc096dd240" args="(CUDPPHandle planHandle, void *d_out, size_t numElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppRand </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&nbsp;</td>
          <td class="paramname"> <em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>numElements</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rand puts <em>numElements</em> random 32-bit elements into <em>d_out</em>. </p>
<p>Outputs <em>numElements</em> random values to <em>d_out</em>. <em>d_out</em> must be of type unsigned int, allocated in device memory.</p>
<p>The algorithm used for the random number generation is stored in <em>planHandle</em>. Depending on the specification of the pseudo random number generator(PRNG), the generator may have one or more seeds. To set the seed, use <a class="el" href="group__public_interface.html#ga9120af9942d2553d2f376ede0f7079dd" title="Sets the seed used for rand.">cudppRandSeed()</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo:</a></b></dt><dd>Currently only MD5 PRNG is supported. We may provide more rand routines in the future.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>planHandle</em>&nbsp;</td><td>Handle to plan for rand </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numElements</em>&nbsp;</td><td>number of elements in d_out. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>d_out</em>&nbsp;</td><td>output of rand, in GPU memory. Should be an array of unsigned integers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__public_interface.html#ga0d39e7c3e14963c7cc3df3b879362c25" title="Create a CUDPP plan.">cudppPlan</a>, <a class="el" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when...">CUDPPConfiguration</a>, <a class="el" href="cudpp_8h.html#a6499e5c26f56db82f520367ae853462f" title="Algorithms supported by CUDPP. Used to create appropriate plans using cudppPlan.">CUDPPAlgorithm</a> </dd></dl>

<p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd>Return more specific errors </dd></dl>
</p>

</div>
</div>
<a class="anchor" id="ga9120af9942d2553d2f376ede0f7079dd"></a><!-- doxytag: member="cudpp.cpp::cudppRandSeed" ref="ga9120af9942d2553d2f376ede0f7079dd" args="(const CUDPPHandle planHandle, unsigned int seed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppRandSeed </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&nbsp;</td>
          <td class="paramname"> <em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>seed</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the seed used for rand. </p>
<p>The seed is crucial to any random number generator as it allows a sequence of random numbers to be replicated. Since there may be multiple different rand algorithms in CUDPP, cudppRandSeed uses <em>planHandle</em> to determine which seed to set. Each rand algorithm has its own unique set of seeds depending on what the algorithm needs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>planHandle</em>&nbsp;</td><td>the handle to the plan which specifies which rand seed to set </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>seed</em>&nbsp;</td><td>the value which the internal cudpp seed will be set to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0d39e7c3e14963c7cc3df3b879362c25"></a><!-- doxytag: member="cudpp_plan.cpp::cudppPlan" ref="ga0d39e7c3e14963c7cc3df3b879362c25" args="(CUDPPHandle *planHandle, CUDPPConfiguration config, size_t numElements, size_t numRows, size_t rowPitch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppPlan </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle *&nbsp;</td>
          <td class="paramname"> <em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_u_d_p_p_configuration.html">CUDPPConfiguration</a>&nbsp;</td>
          <td class="paramname"> <em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>numRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>rowPitch</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a CUDPP plan. </p>
<p>A plan is a data structure containing state and intermediate storage space that CUDPP uses to execute algorithms on data. A plan is created by passing to <a class="el" href="group__public_interface.html#ga0d39e7c3e14963c7cc3df3b879362c25" title="Create a CUDPP plan.">cudppPlan()</a> a <a class="el" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when...">CUDPPConfiguration</a> that specifies the algorithm, operator, datatype, and options. The size of the data must also be passed to <a class="el" href="group__public_interface.html#ga0d39e7c3e14963c7cc3df3b879362c25" title="Create a CUDPP plan.">cudppPlan()</a>, in the <em>numElements</em>, <em>numRows</em>, and <em>rowPitch</em> arguments. These sizes are used to allocate internal storage space at the time the plan is created. The CUDPP planner may use the sizes, options, and information about the present hardware to choose optimal settings.</p>
<p>Note that <em>numElements</em> is the maximum size of the array to be processed with this plan. That means that a plan may be re-used to process (for example, to sort or scan) smaller arrays.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>planHandle</em>&nbsp;</td><td>A pointer to an opaque handle to the internal plan </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>config</em>&nbsp;</td><td>The configuration struct specifying algorithm and options </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numElements</em>&nbsp;</td><td>The maximum number of elements to be processed </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numRows</em>&nbsp;</td><td>The number of rows (for 2D operations) to be processed </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rowPitch</em>&nbsp;</td><td>The pitch of the rows of input data, in elements </td></tr>
  </table>
  </dd>
</dl>

<p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000016">Todo:</a></b></dt><dd>: implement cudppReduce() </dd></dl>
</p>

</div>
</div>
<a class="anchor" id="ga4015898886e140ad95f320ab4c07db2c"></a><!-- doxytag: member="cudpp_plan.cpp::cudppDestroyPlan" ref="ga4015898886e140ad95f320ab4c07db2c" args="(CUDPPHandle planHandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppDestroyPlan </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&nbsp;</td>
          <td class="paramname"> <em>planHandle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy a CUDPP Plan. </p>
<p>Deletes the plan referred to by <em>planHandle</em> and all associated internal storage.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>planHandle</em>&nbsp;</td><td>The CUDPPHandle to the plan to be destroyed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4ef1a005ba96fccd6eb4204dc33f4f88"></a><!-- doxytag: member="cudpp_plan.cpp::cudppSparseMatrix" ref="ga4ef1a005ba96fccd6eb4204dc33f4f88" args="(CUDPPHandle *sparseMatrixHandle, CUDPPConfiguration config, size_t numNonZeroElements, size_t numRows, const void *A, const unsigned int *h_rowIndices, const unsigned int *h_indices)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppSparseMatrix </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle *&nbsp;</td>
          <td class="paramname"> <em>sparseMatrixHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_u_d_p_p_configuration.html">CUDPPConfiguration</a>&nbsp;</td>
          <td class="paramname"> <em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>numNonZeroElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>numRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&nbsp;</td>
          <td class="paramname"> <em>h_rowIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&nbsp;</td>
          <td class="paramname"> <em>h_indices</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a CUDPP Sparse Matrix Object. </p>
<p>The sparse matrix plan is a data structure containing state and intermediate storage space that CUDPP uses to perform sparse matrix dense vector multiply. This plan is created by passing to CUDPPSparseMatrixVectorMultiplyPlan() a <a class="el" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when...">CUDPPConfiguration</a> that specifies the algorithm (sprarse matrix-dense vector multiply) and datatype, along with the sparse matrix itself in CSR format. The number of non-zero elements in the sparse matrix must also be passed as <em>numNonZeroElements</em>. This is used to allocate internal storage space at the time the sparse matrix plan is created.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>sparseMatrixHandle</em>&nbsp;</td><td>A pointer to an opaque handle to the sparse matrix object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>config</em>&nbsp;</td><td>The configuration struct specifying algorithm and options </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numNonZeroElements</em>&nbsp;</td><td>The number of non zero elements in the sparse matrix </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numRows</em>&nbsp;</td><td>This is the number of rows in y, x and A for y = A * x </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>A</em>&nbsp;</td><td>The matrix data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>h_rowIndices</em>&nbsp;</td><td>An array containing the index of the start of each row in <em>A</em> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>h_indices</em>&nbsp;</td><td>An array containing the index of each nonzero element in <em>A</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae0644c758120abaef0e2bb396f57cefb"></a><!-- doxytag: member="cudpp_plan.cpp::cudppDestroySparseMatrix" ref="gae0644c758120abaef0e2bb396f57cefb" args="(CUDPPHandle sparseMatrixHandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppDestroySparseMatrix </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&nbsp;</td>
          <td class="paramname"> <em>sparseMatrixHandle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy a CUDPP Sparse Matrix Object. </p>
<p>Deletes the sparse matrix data and plan referred to by <em>sparseMatrixHandle</em> and all associated internal storage.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sparseMatrixHandle</em>&nbsp;</td><td>The CUDPPHandle to the matrix object to be destroyed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Thu Mar 11 14:59:04 2010 for CUDPP by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
